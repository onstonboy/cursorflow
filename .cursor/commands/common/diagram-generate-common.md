/*
Generated by Copilot
This document contains standardized prompts for generating diagrams from code/business logic.
*/

# Reusable Prompt Templates for Diagram Generation

## ðŸ¤– AI Assistant Instructions: How to Recognize User Intent

**CRITICAL: Read this section first before responding to any diagram request!**

### Step 1: Analyze User's Request

**Look for these indicators to determine diagram style:**

**Option 1 - Detailed Technical Diagram:**
- Keywords: "technical", "code flow", "implementation", "method names", "API endpoints", "error handling", "debugging", "code review"
- Audience mentions: "developer", "tech lead", "engineering team", "scrum master"
- Phrases: "analyze", "trace code", "show exact implementation", "detailed flow"
- Shortcuts: "analyze [flow] start from [Activity]"

**Option 2 - Business Logic Diagram:**
- Keywords: "business logic", "high-level", "business process", "business decisions", "stakeholder", "product"
- Audience mentions: "product owner", "product manager", "business analyst", "BA"
- Phrases: "business flow", "what happens", "business perspective", "for stakeholders"
- Shortcuts: "business logic for [feature]"

**Option 3 - Executive/Manager Report Diagram:**
- Keywords: "executive", "manager", "plain language", "simple terms", "non-technical", "report", "presentation"
- Audience mentions: "executives", "management", "C-level", "board", "investors", "non-technical"
- Phrases: "for managers", "easy to understand", "explain simply", "status report"
- Shortcuts: "executive report for [feature]"

**Option 4 - Screen/Page Flow Diagram (UI/UX):**
- Keywords: "screen flow", "page flow", "UI flow", "UX flow", "user journey", "navigation", "screens", "pages", "user interface"
- Audience mentions: "UI/UX designer", "designer", "QA", "testers", "UI team", "UX team"
- Phrases: "screen transitions", "page navigation", "what user sees", "UI perspective", "user interface flow"
- Shortcuts: "screen flow for [feature]"

### Step 2: Decision Logic

```
IF user request contains CLEAR indicators from Option 1, 2, 3, or 4:
    â†’ Proceed with that diagram style
    â†’ Acknowledge which style you're using
    â†’ Ask for any missing details (files, starting point, etc.)

ELSE IF user request is ambiguous or unclear:
    â†’ SHOW THE INTERACTIVE MENU (below)
    â†’ Wait for user to select 1, 2, 3, or 4
    â†’ DO NOT ASSUME OR GUESS

ELSE IF user just says "create diagram" or "generate flow":
    â†’ SHOW THE INTERACTIVE MENU
    â†’ DO NOT ASSUME
```

### Step 3: Confirm Before Generating

**Always confirm with the user:**
```
"ðŸ” **RUNNING: [STYLE NAME]**

I'll generate a [STYLE NAME] diagram for [FEATURE/FLOW]. 
This will include [KEY CHARACTERISTICS].
Is this correct, or would you like a different style?"
```

**Example confirmations:**
- "ðŸ” **RUNNING: Option 1 - Detailed Technical Diagram** \n\nI'll generate a **Detailed Technical Diagram** showing all method calls, API endpoints, and error handling. Correct?"
- "ðŸ” **RUNNING: Option 2 - Business Logic Diagram** \n\nI'll create a **Business Logic Diagram** with business terminology for stakeholders. Is this what you need?"
- "ðŸ” **RUNNING: Option 3 - Executive Report Diagram** \n\nI'll prepare an **Executive Report Diagram** in plain language for management. Proceed?"
- "ðŸ” **RUNNING: Option 4 - Screen/Page Flow Diagram** \n\nI'll create a **Screen/Page Flow Diagram** showing UI navigation and user interactions. Is this correct?"

### Quick Reference Card for AI

| User Says | Contains Keywords | Action |
|-----------|-------------------|--------|
| "analyze code flow starting from..." | "analyze", "code flow" | â†’ Use Option 1 (Technical) |
| "business logic for stakeholders" | "business logic", "stakeholders" | â†’ Use Option 2 (Business) |
| "executive report in simple terms" | "executive", "simple terms" | â†’ Use Option 3 (Executive) |
| "screen flow for checkout" | "screen flow" | â†’ Use Option 4 (UI/UX) |
| "create a diagram" | No clear indicators | â†’ **SHOW MENU** |
| "show me the flow" | Ambiguous | â†’ **SHOW MENU** |
| "generate diagram for user registration" | No audience specified | â†’ **SHOW MENU** |
| "diagram for devs and managers" | Multiple audiences | â†’ **SHOW MENU** |

**REMEMBER: If unsure â†’ SHOW MENU. Never assume!**

---

## ðŸŽ¯ Interactive Menu - Choose Your Diagram Style

**Please select the diagram style that best fits your needs:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DIAGRAM GENERATION MENU                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  1ï¸âƒ£  DETAILED TECHNICAL DIAGRAM                                     â”‚
â”‚     â€¢ Shows complete code flow with all technical details          â”‚
â”‚     â€¢ Includes method names, API endpoints, error handling         â”‚
â”‚     â€¢ Recommended for: Developers, Scrum Masters, Tech Leads       â”‚
â”‚     â€¢ Use when: Code reviews, debugging, technical documentation   â”‚
â”‚                                                                     â”‚
â”‚  2ï¸âƒ£  BUSINESS LOGIC DIAGRAM                                         â”‚
â”‚     â€¢ Focuses on business processes and decisions                  â”‚
â”‚     â€¢ Uses business terminology, no technical jargon               â”‚
â”‚     â€¢ Recommended for: Product Owners, Product Managers, BA        â”‚
â”‚     â€¢ Use when: Requirements docs, stakeholder presentations       â”‚
â”‚                                                                     â”‚
â”‚  3ï¸âƒ£  PLAIN LANGUAGE DIAGRAM (EXECUTIVE REPORT)                      â”‚
â”‚     â€¢ 100% accurate flow in everyday language                      â”‚
â”‚     â€¢ No technical terms, easy for anyone to understand            â”‚
â”‚     â€¢ Recommended for: Managers, Executives, Non-technical teams   â”‚
â”‚     â€¢ Use when: Status reports, management presentations, audits   â”‚
â”‚                                                                     â”‚
â”‚  4ï¸âƒ£  SCREEN/PAGE FLOW DIAGRAM (UI/UX)                               â”‚
â”‚     â€¢ Shows screen-to-screen navigation and user interactions      â”‚
â”‚     â€¢ Focuses on what users see and do at each step               â”‚
â”‚     â€¢ Recommended for: UI/UX Designers, QA, Testers, Product Team â”‚
â”‚     â€¢ Use when: UI documentation, testing, user journey mapping    â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Enter your choice (1, 2, 3, or 4):
```

---

### ðŸ“‹ How to Use This Menu:

**Option 1: Interactive Selection**
1. Type your selection number (1, 2, or 3) in the chat
2. I will automatically apply the corresponding prompt template
3. Provide the required information (files, starting point, feature name)
4. I'll generate the diagram based on your selected style

**Option 2: Direct Shortcut (Skip Menu)**
- If you already know which style you want, use the shortcuts in the next section

---

## ðŸ“– Quick Start - How to Use These Prompts

### âš¡ Fastest Way - Use Shortcuts:

**Method 1: Using Shortcut Prompts (Recommended)**

Just type one of these simple commands:

1. **To analyze code and generate diagram:**
   ```
   analyze "checkout flow" start from "CheckoutController" when "user clicks submit button" using #file:diagram-generate-rule.md 
   ```

2. **To convert Mermaid to Draw.io:**
   ```
   convert "path/to/diagram.md" to drawio using #file:diagram-generate-rule.md 
   ```

See the **Quick Shortcut Prompts** section at the top for more examples.

---

### ðŸ“ Alternative Method - Full Template Process

---

## âš¡ Quick Shortcut Prompts

### For Quick Diagram Generation:

**Shortcut 1: Analyze & Generate Mermaid Diagram**
```
analyze "[flow/logic name]" start from "[ClassName/ModuleName/ComponentName]" when "[user action]" using #file:diagram-generate-rule.md 
```
*This triggers Option 1: Detailed Technical Diagram*

**Example:**
```
analyze "order checkout flow" start from "CheckoutController" when "user clicks submit order" using #file:diagram-generate-rule.md 
```

**Shortcut 2: Generate Business Logic Diagram**
```
business logic for "[feature/flow name]" start from "[ClassName/ModuleName/ComponentName]" using #file:diagram-generate-rule.md 
```
*This triggers Option 2: Business Logic Diagram*

**Example:**
```
business logic for "order checkout process" start from "CheckoutController" using #file:diagram-generate-rule.md 
```

**Shortcut 3: Generate Executive/Manager Report Diagram**
```
executive report for "[feature/flow name]" start from "[ClassName/ModuleName/ComponentName]" using #file:diagram-generate-rule.md 
```
*This triggers Option 3: Plain Language Diagram*

**Example:**
```
executive report for "order checkout process" start from "CheckoutController" using #file:diagram-generate-rule.md 
```

**Shortcut 4: Generate Screen/Page Flow Diagram**
```
screen flow for "[feature/flow name]" start from "[ClassName/ModuleName/ComponentName]" using #file:diagram-generate-rule.md 
```
*This triggers Option 4: Screen/Page Flow Diagram (UI/UX)*

**Example:**
```
screen flow for "order checkout" start from "CheckoutPage" using #file:diagram-generate-rule.md 
```

### ðŸ” How Shortcuts Work:

**Shortcut 1** triggers Option 1 - Detailed Technical Diagram (Prompt 1):
- `"[flow/logic name]"` â†’ Describes what you're analyzing (e.g., "checkout flow", "authentication process", "data sync")
- `"[ClassName/ModuleName/ComponentName]"` â†’ The starting point (e.g., "OrderService", "AuthController", "UserComponent")
- `"[user action]"` â†’ What triggers the flow (e.g., "clicks submit", "submits form", "initiates request")

**Shortcut 2** triggers Option 2 - Business Logic Diagram (Prompt 2):
- Analyzes code to extract business logic flow
- Creates a high-level Mermaid diagram focused on business decisions
- Abstracts away technical implementation details

**Shortcut 3** triggers Option 3 - Plain Language Diagram (Prompt 3):
- Creates an executive-level diagram for managers/non-technical stakeholders
- Uses plain language that anyone can understand
- Maintains 100% accuracy of flow, boxes, arrows, and meaning from the actual code

**Shortcut 4** triggers Option 4 - Screen/Page Flow Diagram (Prompt 4):
- Traces actual code to identify screen navigation and transitions
- Shows what users see and interact with at each step
- Focuses on UI elements, buttons, forms, and page transitions
- Perfect for UI/UX designers, QA testers, and product teams

### ðŸ’¡ When to Use Each Method:

**AI Assistant: CRITICAL - Always Announce Your Action:**
- **BEFORE starting any diagram generation, ALWAYS announce which prompt/style you're using**
- Example: "I'll use **Option 1: Detailed Technical Diagram** to analyze this flow..."
- Example: "I'm generating a **Business Logic Diagram (Prompt 2)** for stakeholders..."
- Example: "Creating an **Executive Report Diagram (Prompt 3)** in plain language..."
- Example: "Creating a **Screen/Page Flow Diagram (Prompt 4)** for UI/UX team..."
- **This confirmation allows users to correct if you've misunderstood their intent**

**AI Assistant: ALWAYS show the menu when:**
- User request doesn't contain clear style indicators
- User just says "create diagram" or "generate flow" without specifying audience
- No clear keywords for technical/business/executive/UI style
- Ambiguous requests like "show me the flow" or "I need a diagram"
- User mentions multiple audiences (e.g., "for developers and managers")
- You're uncertain which style would be most appropriate
- **GOLDEN RULE: When in doubt, show the menu. NEVER assume.**

**Use Interactive Menu when:**
- You're new to this system and want guidance
- You're unsure which diagram style fits your needs
- You want to see recommendations based on your role
- The AI assistant cannot determine your intent clearly

**Use Shortcuts when:**
- You clearly specify the style you want
- You use the exact shortcut keywords ("analyze", "business logic", "executive report")
- Your request clearly mentions the target audience
- You're familiar with the three diagram styles
- You want quick results with standard options
- You're analyzing standard flows (activities, fragments, user actions)

**Use Full Templates when:**
- You need to customize specific requirements
- You want to analyze complex, multi-file systems
- You need special styling or grouping options
- You want to specify additional context or constraints

---

## ðŸ“ AI Response Examples: How to Handle Different Requests

**Example 1: Clear Technical Request**
```
User: "Analyze the checkout flow starting from CheckoutService showing all method calls and error handling"

AI Response:
âœ… "ðŸ” **RUNNING: Option 1 - Detailed Technical Diagram**

I'll generate a **Detailed Technical Diagram** (Prompt 1) for the checkout flow. 
This will include all method calls, API endpoints, error handling, and technical details.

Please provide:
- Which files should I analyze? (e.g., CheckoutService.java, OrderProcessor.py, checkout_controller.rb)
- Any specific scenarios to focus on?"
```

**Example 2: Clear Business Request**
```
User: "Create a business logic diagram for the order fulfillment process for stakeholders"

AI Response:
âœ… "ðŸ” **RUNNING: Option 2 - Business Logic Diagram**

I'll generate a **Business Logic Diagram** (Prompt 2) for the order fulfillment process.
This will use business terminology suitable for stakeholders, without technical jargon.

Please specify:
- Which files/classes should I analyze?
- What's the starting point of the fulfillment process?"
```

**Example 3: Clear Executive Request**
```
User: "I need a simple diagram in plain language for management to understand the user authentication flow"

AI Response:
âœ… "ðŸ” **RUNNING: Option 3 - Executive/Manager Report Diagram**

I'll generate an **Executive/Manager Report Diagram** (Prompt 3) for the authentication flow.
This will use plain, everyday language that management can easily understand.

Please provide:
- Which files implement the authentication flow?
- What's the entry point (e.g., user opens login page)?"
```

**Example 4: Clear UI/UX Request**
```
User: "Show me the screen flow for the checkout feature from the UI perspective"

AI Response:
âœ… "ðŸ” **RUNNING: Option 4 - Screen/Page Flow Diagram**

I'll generate a **Screen/Page Flow Diagram** (Prompt 4) showing all screen transitions and user interactions.
This will trace the actual code to show accurate navigation and UI elements.

Please provide:
- Which views/pages/components should I analyze?
- What's the starting screen (e.g., Shopping Cart Page)?"
```

**Example 5: Ambiguous Request - MUST SHOW MENU**
```
User: "Generate a diagram for the checkout flow"

AI Response:
âœ… "I can create a diagram for the checkout flow. To ensure I provide the right level of detail, please select your preferred diagram style:

[SHOW THE FULL INTERACTIVE MENU HERE]

Which option would you like (1, 2, 3, or 4)?"
```

**Example 6: Unclear Audience - MUST SHOW MENU**
```
User: "Show me how the third-party API integration works"

AI Response:
âœ… "I can analyze the third-party API integration. To provide the most useful diagram for your needs, please select the diagram style:

[SHOW THE FULL INTERACTIVE MENU HERE]

Which style would be most helpful for you?"
```

**Example 7: Multiple Audiences - MUST SHOW MENU**
```
User: "Create a diagram for both developers and product managers"

AI Response:
âœ… "I recommend creating separate diagrams for different audiences. Let's start with the first one. Please select which diagram to create first:

[SHOW THE FULL INTERACTIVE MENU HERE]

After completing the first diagram, I can generate the second one in a different style."
```

---

## ðŸ“– Quick Start - How to Use These Prompts

### Simple 2-Step Process:

#### **Step 1: Generate Detailed Mermaid Diagram from Code**
1. Scroll down to **"Prompt 1: Analyze Code & Generate Mermaid Diagram"**
2. **Copy the entire template** (from "I need you to analyze..." to "...EXACT code flow")
3. **Customize these parts:**
   - `[List the specific files, classes, or methods to analyze]` â†’ Add your actual file names
   - `[Specify the entry point...]` â†’ Add where the flow starts (e.g., "User clicks Login button")
4. **Paste the customized prompt** to your AI assistant (GitHub Copilot, ChatGPT, Claude, etc.)
5. **Review the Mermaid diagram code** the AI generates

#### **Step 2: Generate Business Logic Mermaid Diagram**
1. Scroll down to **"Prompt 2: Generate Business Logic Mermaid Diagram"**
2. **Copy the entire template** (from "I need you to analyze..." to "...business decisions")
3. **Customize these parts:**
   - `[List the specific files...]` â†’ Add your actual file names
   - `[Specify the business feature...]` â†’ Add the feature name
4. **Paste the customized prompt** to your AI assistant
5. **Review the high-level business logic diagram** the AI generates

#### **Step 3: Generate Executive/Manager Report Diagram**
1. Scroll down to **"Prompt 3: Generate Executive/Manager Report Diagram"**
2. **Copy the entire template** (from "I need you to analyze..." to "...for reporting")
3. **Customize these parts:**
   - `[List the specific files...]` â†’ Add your actual file names
   - `[Specify the feature...]` â†’ Add the feature name
4. **Paste the customized prompt** to your AI assistant
5. **Review the manager-friendly diagram** the AI generates

### ðŸ“¹ Visual Example:

```
You: [Copy Prompt 1 template, customize file names]
     "I need you to analyze OrderService.java and create a Mermaid flowchart..."

AI:  [Generates detailed Mermaid code with all technical details]
     ```mermaid
     flowchart TD
         Start([User submits order]) --> CheckValid{Valid?}
         CheckValid -->|Yes| CallAPI[ðŸ“¡ Call payment gateway API]
         ...
     ```

You: [Copy Prompt 2 template for business logic version]
     "I need you to analyze the business logic and create a high-level Mermaid diagram..."

AI:  [Generates business-focused Mermaid code]
     ```mermaid
     flowchart TD
         Start([Customer Places Order]) --> Validate{Validate Order Details}
         Validate -->|Valid| Process[Process Transaction]
         ...
     ```

You: [Copy Prompt 3 template for executive report]
     "I need you to analyze and create an executive report diagram..."

AI:  [Generates manager-friendly Mermaid code with plain language]
     ```mermaid
     flowchart TD
         Start([Customer Completes Purchase]) --> Check{Check Information}
         Check -->|All Good| Submit[Send to Payment System]
         ...
     ```

You: Use the appropriate diagram based on your audience âœ…
```

### ðŸ’¡ Pro Tips:
- **Test the Mermaid code first** at review whole the mermaid code to ensure accuracy
- **Be specific with file names** in all prompts for better accuracy
- **Use Prompt 1** for detailed technical documentation and code reviews
- **Use Prompt 2** for business presentations and high-level discussions
- **Use Prompt 3** for executive reports and manager presentations
- **Use Prompt 4** for UI/UX documentation and QA testing
- **For large codebases**, analyze one feature/module at a time
- **Diagrams are auto-saved** in `doc/diagrams/` folder organized by type

---

## ï¿½ðŸ“‹ Prompt 1: Analyze Code & Generate Mermaid Diagram

### Template

```
I need you to analyze the code/business logic and create a comprehensive Mermaid flowchart diagram.

**Requirements:**
1. **Trace the EXACT code execution flow** - Follow the actual implementation, not assumptions. Read and analyze ALL related files completely before creating the diagram.
2. **Include ALL decision points** - Every if/else, switch case, when branch, ternary operator, null checks, optional chaining
3. **Show ALL API calls** - Mark with ðŸ“¡ emoji, include endpoint paths and HTTP methods
4. **Document ALL possible outcomes** - Success paths, error paths, timeout scenarios, edge cases, boundary conditions
5. **Capture ALL error handling** - Every try/catch block, error response, failure case, exception handling, error callbacks, fallback mechanisms
6. **Include ALL edge cases** - Null/undefined values, empty collections, invalid inputs, network failures, timeout scenarios, concurrent operations
7. **Show data flow** - What data is passed between functions/methods, data transformations, validations
8. **Include user interactions** - Button clicks, form submissions, OTP entry, gestures, navigation events
9. **Mark important operations** - Database operations, state changes, validations, cache operations, logging
10. **Analyze thoroughly** - Read through the entire codebase related to the feature. Don't skip any files, methods, or code branches. Follow all function calls to their implementations.

**Diagram Structure:**
- Use `flowchart TD` (top-down layout)
- Use descriptive node labels with function/method names
- Use decision diamonds `{}` for all conditional logic (including edge cases like null checks, empty checks, boundary validations)
- Use rounded rectangles `[]` for process steps
- Use rounded edges `([])` for start/end states
- Label ALL edges with conditions (Yes/No, success/failure, specific result types, error types, edge case conditions)
- Show ALL code branches - don't skip any if/else paths, error paths, or edge case handlers

**Styling Requirements:**
- ðŸŸ¢ **Start/Success nodes**: Green background (#2E7D32), green stroke (#1B5E20), white text
- ðŸ”µ **API call nodes**: Blue background (#1565C0), dark blue stroke (#0D47A1), white text
- ðŸ”´ **Error nodes**: Red background (#C62828), dark red stroke (#B71C1C), white text
- âšª **Regular process nodes**: Default styling
- **Decision diamonds**: Default styling

**Additional Notes:**
- Add comments/notes explaining complex logic
- Group related flows with subgraphs if needed
- Show parallel operations if they exist
- Include retry logic, fallback mechanisms, circuit breakers
- Document feature flags or conditional execution paths
- **CRITICAL**: Analyze the COMPLETE code flow before creating the diagram. Don't make assumptions about what code does - read it thoroughly.
- Trace ALL function calls to their implementations
- Follow ALL code paths including error handlers, catch blocks, finally blocks, cleanup handlers
- Include ALL edge case validations (null checks, empty checks, range validations, type checks)
- Document timeout handlers, rate limiting, throttling logic
- Show ALL async/await patterns, promise chains, callback flows
- Include state machine transitions if present
- Document all logging, monitoring, or analytics points if critical to understanding flow

**Files to analyze:**
[List the specific files, classes, or methods to analyze]

**Starting point:**
[Specify the entry point - e.g., "Start from when user clicks the Pay button"]

**Analysis Process:**
1. **First Pass**: Read ALL files completely to understand the overall structure
2. **Second Pass**: Trace the execution flow from the entry point, following every function call
3. **Third Pass**: Identify ALL decision points, error handlers, and edge cases
4. **Fourth Pass**: Verify all paths lead to proper outcomes (success, error, or termination)
5. **Create Diagram**: Build the flowchart with complete accuracy including ALL scenarios

**Output:**
Generate a complete, detailed Mermaid flowchart that accurately represents the EXACT code flow as .md file.
The diagram MUST include:
- ALL success scenarios and happy paths
- ALL error scenarios and failure paths
- ALL edge cases handled in the code
- ALL retry/fallback mechanisms
- ALL validation and boundary checks
- ALL timeout and async handling
Save the diagram to: `doc/diagrams/technical/[feature-name]-technical.md`
```

### Example Usage

```
I need you to analyze the code/business logic and create a comprehensive Mermaid flowchart diagram.

**Requirements:**
[All requirements as listed above]

**Files to analyze:**
- OrderController.java
- PaymentService.py
- CheckoutProcessor.ts
- PaymentGatewayClient.cs
- OrderValidation.rb
- All related payment processing modules

**Starting point:**
Start from when user clicks the "Complete Order" button in the checkout interface

**Output:**
Generate a complete, detailed Mermaid flowchart that accurately represents the EXACT code flow as .md file.
Save the diagram to: `doc/diagrams/technical/[feature-name]-technical.md`
```

---

## ðŸŽ¨ Prompt 2: Generate Business Logic Mermaid Diagram

### Template

```
I need you to analyze the code and create a HIGH-LEVEL business logic Mermaid flowchart diagram focused on business decisions and flow, NOT technical implementation details.

**Requirements:**
1. **Trace the EXACT code execution flow** - Follow the actual implementation, not assumptions. Read and analyze ALL related files completely before creating the diagram.
2. **Include ALL decision points** - Every if/else, switch case, when branch, ternary operator, null checks, optional chaining
3. **Show ALL API calls** - Mark with ðŸ“¡ emoji, but describe as "External system requests" or "Payment gateway"
4. **Document ALL possible outcomes** - Success paths, error paths, timeout scenarios, edge cases, boundary conditions
5. **Capture ALL error handling** - Every try/catch block, error response, failure case, exception handling, error callbacks, fallback mechanisms
6. **Include ALL edge cases** - Null/undefined values, empty collections, invalid inputs, network failures, timeout scenarios, concurrent operations
7. **Show data flow** - What data is passed between functions/methods (in business terms)
8. **Include user interactions** - Button clicks, form submissions, OTP entry, gestures, navigation events
9. **Mark important operations** - Database operations (as "data storage"), state changes, validations, cache operations
10. **Use business terminology** - Translate technical terms to business language
11. **Keep it understandable** - Explain the "what" using business terms, not the "how"
12. **Analyze thoroughly** - Read through the entire codebase related to the feature. Don't skip any files, methods, or code branches. Follow all function calls to their implementations.

**What to INCLUDE:**
- ALL decision points from the code (if/else, when, switch) - described in business terms
- ALL API calls - described as "Request to [System Name]" or "Contact [External Service]"
- ALL error handling paths - described as "If problem occurs" or "When [issue] happens"
- ALL timeout and retry logic - described as "Wait for response" or "Try again"
- ALL data validations - described as "Check [business requirement]"
- ALL user interactions - button clicks, form inputs, confirmations
- ALL possible outcomes - success, failure, cancellation, timeout
- ALL state changes - described as business status changes
- ALL database operations - described as "Save information" or "Retrieve data"
- Business processes (e.g., "Validate Payment Information", "Process Order")
- Business decisions (e.g., "Is customer eligible?", "Sufficient funds?")
- User actions (e.g., "User selects payment method", "User confirms booking")
- Business outcomes (e.g., "Order Confirmed", "Payment Failed", "Booking Cancelled")
- External system interactions at business level (e.g., "Payment Gateway", "Booking System")
- Business rules and validations

**What to EXCLUDE:**
- Specific method or function names (e.g., `processPayment()`, `validateUserInput()`)
- Technical API endpoints (e.g., `/api/v1/payment/authorize`)
- Implementation details (e.g., database operations, state management)
- Technical error handling (e.g., NullPointerException, timeout retries)
- Code-level data transformations
- Technical parameters or response objects

**Diagram Structure:**
- Use `flowchart TD` (top-down layout)
- Use business-friendly labels without technical jargon
- Use decision diamonds `{}` for business decision points
- Use rounded rectangles `[]` for business processes
- Use rounded edges `([])` for start/end states
- Label edges with business conditions (e.g., "Approved", "Rejected", "Cancelled")

**Styling Requirements:**
- ðŸŸ¢ **Start/Success states**: Green background (#2E7D32), white text
- ðŸ”µ **External system interactions**: Blue background (#1565C0), white text
- ðŸ”´ **Failure/Error states**: Red background (#C62828), white text
- âšª **Regular business processes**: Default styling
- **Decision points**: Default styling with clear Yes/No or condition labels

**Additional Notes:**
- Add comments/notes explaining complex business logic
- Group related flows with subgraphs if needed
- Show parallel operations if they exist (e.g., "Meanwhile, system also...")
- Include retry logic (e.g., "Try up to 3 times")
- Include fallback mechanisms (e.g., "If primary method fails, use alternative")
- Document feature flags or conditional execution paths
- Keep the diagram readable - aim for 15-25 nodes maximum
- DO NOT skip any steps that exist in the actual code
- DO NOT combine separate code steps into one box
- Every branch in the code must be a branch in the diagram
- **CRITICAL**: Analyze the COMPLETE code flow before creating the diagram. Don't make assumptions about what code does - read it thoroughly.
- Trace ALL function calls to their implementations
- Follow ALL code paths including error handlers, catch blocks, finally blocks, cleanup handlers
- Include ALL edge case validations (null checks, empty checks, range validations, type checks)
- Document timeout handlers, rate limiting, throttling logic (in business terms)
- Show ALL async operations, waiting periods, retry mechanisms
- Include state transitions if present
- Document all critical business decision points

**Files to analyze:**
[List the specific files, classes, or modules to analyze]

**Business feature:**
[Specify the business feature or flow - e.g., "Payment processing workflow", "Flight booking flow"]

**Analysis Process:**
1. **First Pass**: Read ALL files completely to understand the overall business process
2. **Second Pass**: Trace the execution flow, identifying business decisions and outcomes
3. **Third Pass**: Identify ALL decision points, error scenarios, and edge cases from the code
4. **Fourth Pass**: Translate technical implementation to business terminology
5. **Create Diagram**: Build the flowchart with complete accuracy including ALL business scenarios

**Output:**
Generate a clean, business-focused Mermaid flowchart as .md file that:
1. Accurately represents the EXACT code flow (every step, decision, and outcome)
2. Can be understood by non-technical stakeholders using business terminology
3. Shows the business logic and key decision points without technical jargon
4. Maintains 100% accuracy - no steps skipped, no steps combined
5. Translates ALL technical concepts to business language
6. Includes ALL edge cases and error scenarios handled in the code
7. Shows ALL retry mechanisms and fallback options
Save the diagram to: `doc/diagrams/business/[feature-name]-business.md`
```

### Example Usage

```
I need you to analyze the code and create a HIGH-LEVEL business logic Mermaid flowchart diagram focused on business decisions and flow, NOT technical implementation details.

**Requirements:**
[All requirements as listed above]

**Files to analyze:**
- GooglePayPaymentDetailsActivity.kt
- GooglePayPaymentDetailsPresenter.kt
- GooglePayProvider.kt
- Payment-related providers in the payment module

**Business feature:**
[Specify the business feature or flow - e.g., "Payment processing workflow", "Flight booking flow"]

**Output:**
Generate a clean, business-focused Mermaid flowchart as .md file that:
1. Accurately represents the EXACT code flow (every step, decision, and outcome)
2. Can be understood by non-technical stakeholders using business terminology
3. Shows the business logic and key decision points without technical jargon
4. Maintains 100% accuracy - no steps skipped, no steps combined
5. Translates ALL technical concepts to business language
```

### Example Usage

```
I need you to analyze the code and create a HIGH-LEVEL business logic Mermaid flowchart diagram focused on business decisions and flow, NOT technical implementation details.

**Requirements:**
[All requirements as listed above]

**Files to analyze:**
- OrderController.java
- PaymentService.py
- CheckoutProcessor.ts
- Payment-related modules in the checkout system

**Business feature:**
Order checkout and payment processing workflow

**Output:**
Generate a clean, business-focused Mermaid flowchart as .md file that:
1. Accurately represents the EXACT code flow (every step, decision, and outcome)
2. Can be understood by non-technical stakeholders using business terminology
3. Shows the business logic and key decision points without technical jargon
4. Maintains 100% accuracy - no steps skipped, no steps combined
5. Translates ALL technical concepts to business language
Save the diagram to: `doc/diagrams/business/[feature-name]-business.md`
```

---

## ðŸŽ¨ Prompt 3: Generate Executive/Manager Report Diagram

### Template

```
I need you to analyze the code and create an EXECUTIVE-LEVEL Mermaid flowchart diagram for managers and non-technical stakeholders. The diagram must be 100% ACCURATE to the actual code flow, but explained in plain, everyday language.

**CRITICAL REQUIREMENTS:**

**1. ACCURACY (Most Important):**
- **Read ALL related files completely before creating the diagram** - Don't make assumptions
- Every box, arrow, and decision point must match the ACTUAL code flow exactly
- Do NOT simplify or skip any steps that exist in the code
- Do NOT combine steps that are separate in the code
- All conditions and branching logic must be accurate
- All paths (success, failure, alternative) must be shown correctly
- The flow sequence must match the exact code execution order
- Include ALL decision points - Every if/else, switch case, when branch, ternary operator, null checks
- Show ALL API calls/external system requests
- Document ALL possible outcomes - Success paths, error paths, timeout scenarios, edge cases
- Capture ALL error handling - Every try/catch block, error response, failure case, exception handling, error callbacks, fallback mechanisms
- Include ALL edge cases - Null/undefined values, empty collections, invalid inputs, network failures, timeout scenarios, concurrent operations
- Show data flow - What data is passed between steps
- Include ALL user interactions - Button clicks, form submissions, OTP entry, gestures, navigation events
- Mark ALL important operations - Database operations, state changes, validations, cache operations
- Include ALL retry logic and fallback mechanisms
- **Trace ALL function calls to their implementations** - Follow the code execution completely
- Follow ALL code paths including finally blocks, cleanup handlers, and state cleanup
- Include ALL boundary validations, range checks, and type validations

**2. LANGUAGE (Plain English Only):**
- Use everyday language that anyone can understand
- NO technical terms (no API, endpoints, methods, functions, classes)
- NO code terminology (no variables, parameters, objects, exceptions)
- NO technical jargon (no authentication, authorization, serialization)
- Explain WHAT happens, not HOW it's technically implemented
- Use customer/user perspective language

**Translation Guide for Technical Terms:**
- "API call" â†’ "Send request to external system"
- "Validate token" â†’ "Check security credentials"
- "Exception/Error" â†’ "Problem occurs"
- "Timeout" â†’ "System takes too long to respond"
- "Success response" â†’ "Confirmation received"
- "Database query" â†’ "Look up information"
- "Session expired" â†’ "User needs to log in again"
- "Authentication failed" â†’ "Login details incorrect"
- "if/else statement" â†’ "Check if [condition]" then show two paths
- "try/catch block" â†’ "Attempt [action], if problem occurs..."
- "API endpoint" â†’ "External service" or "Processing system"
- "Method call" â†’ "Perform [action]"
- "Return value" â†’ "Result is [outcome]"
- "Null check" â†’ "Check if information is available"
- "Loop/iteration" â†’ "For each [item]" or "Repeat until [condition]"

**What to INCLUDE (Everything from code):**
- ALL decision points from the code (if/else, when, switch) - in plain language
- ALL API calls - described as "Contact [System Name]"
- ALL error handling paths - described as "If problem occurs"
- ALL timeout and retry logic - described as "Wait up to X seconds" or "Try again"
- ALL data validations - described as "Verify [requirement]"
- ALL user interactions - clicks, inputs, confirmations
- ALL possible outcomes - success, failure, cancellation, timeout
- ALL state changes - described as status updates
- ALL database operations - described as "Save information" or "Retrieve records"
- What the user sees or experiences at each step
- What external systems are involved (described simply)
- Wait times or delays if they exist
- Any retries or alternative paths

**What to EXCLUDE:**
- Technical method/function names
- Code-specific error types (NullPointerException, etc.)
- Technical parameters or data structures
- Implementation frameworks or libraries
- Technical architecture details

**Diagram Structure:**
- Use `flowchart TD` (top-down layout)
- Use clear, simple labels that explain what's happening
- Use decision diamonds `{}` for any choice/check points
- Use rounded rectangles `[]` for action steps
- Use rounded edges `([])` for start/end points
- Label ALL arrows with simple, clear conditions

**Styling Requirements:**
- ðŸŸ¢ **Start/Success**: Green background (#2E7D32), white text
- ðŸ”µ **External systems/Third parties**: Blue background (#1565C0), white text
- ðŸ”´ **Problems/Failures**: Red background (#C62828), white text
- ðŸŸ¡ **Waiting/Delays**: Yellow background (#F9A825), dark text
- âšª **Regular steps**: Default styling
- **Decision points**: Default styling with clear Yes/No labels

**Additional Requirements:**
- Add brief notes if a step needs more explanation
- Show timing if steps have significant delays (e.g., "Usually takes 2-3 seconds")
- Indicate if user interaction is required
- Keep the diagram visually clean - use subgraphs to group related steps
- Aim for 20-30 nodes maximum for readability
- Show parallel operations if they exist (e.g., "At the same time...")
- Include feature flags or conditional paths (e.g., "Only if feature enabled")
- DO NOT skip any code branches or decision points
- DO NOT merge separate sequential steps into one box
- Every code path must have a corresponding diagram path
- **CRITICAL**: Analyze the COMPLETE code flow before creating the diagram. Don't make assumptions about what code does - read it thoroughly.
- Trace ALL function calls to their implementations
- Follow ALL code paths including error handlers, catch blocks, finally blocks, cleanup handlers
- Include ALL edge case validations (explained in plain language)
- Document timeout handlers, retry mechanisms (in simple terms)
- Show ALL async operations, waiting periods
- Include all critical decision points that affect user experience

**Files to analyze:**
[List the specific files, classes, or modules to analyze]

**Feature description:**
[Describe the feature from user/customer perspective - e.g., "How customers pay for their flight bookings using Google Pay"]

**Analysis Process:**
1. **First Pass**: Read ALL files completely to understand the complete user experience
2. **Second Pass**: Trace the execution flow, identifying every step the system takes
3. **Third Pass**: Identify ALL decision points, error scenarios, edge cases, and validations
4. **Fourth Pass**: Translate technical implementation to plain everyday language
5. **Create Diagram**: Build the flowchart with complete accuracy including ALL scenarios in simple terms

**Output:**
Generate a complete, ACCURATE Mermaid flowchart as .md file that:
1. Matches the EXACT code flow without skipping or combining steps
2. Uses plain language that any manager or non-technical person can understand
3. Shows all decision points, outcomes, and paths clearly (including edge cases and error handling)
4. Includes ALL retry mechanisms, timeout handling, and fallback options explained simply
5. Shows ALL edge cases and validations handled in the code (in everyday language)
6. Can be used for executive presentations and management reporting
Save the diagram to: `doc/diagrams/executive/[feature-name]-executive.md`
```

### Example Usage

```
I need you to analyze the code and create an EXECUTIVE-LEVEL Mermaid flowchart diagram for managers and non-technical stakeholders. The diagram must be 100% ACCURATE to the actual code flow, but explained in plain, everyday language.

**CRITICAL REQUIREMENTS:**
[All requirements as listed above]

**Files to analyze:**
- OrderController.java
- PaymentService.py
- CheckoutProcessor.ts
- All payment-related modules

**Feature description:**
How customers complete their purchases online - from clicking the checkout button to receiving order confirmation

**Output:**
Generate a complete, ACCURATE Mermaid flowchart as .md file that:
1. Matches the EXACT code flow without skipping or combining steps
2. Uses plain language that any manager or non-technical person can understand
3. Shows all decision points, outcomes, and paths clearly
4. Can be used for executive presentations and management reporting
Save the diagram to: `doc/diagrams/executive/[feature-name]-executive.md`
```

---

## ðŸ“± Prompt 4: Generate Screen/Page Flow Diagram (UI/UX)

### Template

```
I need you to analyze the code and create a SCREEN/PAGE FLOW Mermaid flowchart diagram showing the user interface navigation and interactions. The diagram must be 100% ACCURATE by tracing the actual code implementation.

**CRITICAL REQUIREMENTS:**

**1. ACCURACY (Trace Actual Code):**
- **Read ALL UI-related files completely before creating the diagram** - Don't make assumptions
- Trace the EXACT code to identify all screen transitions and navigation
- Follow Activity/Fragment launches, intent navigation, screen routing, and navigation controllers
- Every screen shown must exist in the actual codebase
- Every transition arrow must match actual navigation code
- Include ALL possible navigation paths (success, error, back button, cancel, deep links)
- Show the exact sequence of screens as they appear in the code
- Do NOT assume or invent screens that don't exist in the code
- Do NOT skip intermediate screens, dialogs, or loading states
- Include ALL conditional navigation (feature flags, user states, permissions, authentication states)
- **Trace ALL navigation function calls** - Follow navigation methods to understand complete routing logic
- Include ALL edge cases - permission denials, network errors, validation failures that trigger screen changes
- Follow ALL error handling that displays error screens, toasts, or dialogs
- Include ALL timeout scenarios that might change screens or show alerts
- Document ALL back stack management and screen replacement logic

**2. FOCUS ON USER INTERFACE:**
- Show screens/pages/activities/fragments as the main nodes
- Include dialogs, bottom sheets, popups as separate UI elements
- Show user actions that trigger transitions (button clicks, swipes, form submissions)
- Display what users see at each screen (main UI elements, forms, buttons)
- Include loading states, progress indicators, success/error screens
- Show navigation patterns (forward, back, replace, deep link)

**3. USER INTERACTION DETAILS:**
- Label ALL user actions clearly (e.g., "User taps Pay button", "User enters OTP")
- Show form inputs and required fields
- Include validation feedback screens
- Show error messages or error screens
- Display confirmation dialogs or success screens
- Include "Back" button behavior and navigation stack changes

**4. SCREEN INFORMATION:**
- Use screen/page names as node labels (e.g., "Payment Details Screen", "OTP Verification Screen")
- Add brief description of screen purpose
- Show key UI elements on each screen (buttons, forms, lists)
- Indicate if screen is modal, full screen, or overlay
- Show screen state variations (loading, error, success, empty)

**What to INCLUDE:**
- ALL screens/activities/fragments/views/pages in the flow
- ALL dialogs, bottom sheets, alerts, popups, modals
- ALL user interaction points (buttons, links, gestures, swipes, taps)
- ALL navigation transitions (forward, back, replace, finish, push, pop)
- ALL conditional navigation (authentication checks, feature flags, user permissions, user roles)
- ALL error screens and error handling UI (error messages, toasts, snackbars, alert dialogs)
- ALL loading states and progress screens (spinners, skeleton screens, progress bars)
- ALL success/confirmation screens
- ALL validation feedback UI (inline errors, form validation messages)
- Back button and system navigation behavior
- Deep link entry points if applicable
- ALL edge case UI handling (empty states, no network screens, timeout screens)
- ALL permission request dialogs/screens
- ALL retry/refresh UI elements and their navigation
- Splash screens, onboarding flows if they're part of the journey
- Tab navigation, drawer navigation, bottom navigation state changes

**What to EXCLUDE:**
- Backend API implementation details
- Business logic processing (unless it affects UI)
- Technical method names or function calls
- Database operations (unless user-visible)
- Internal state management details
- Technical error handling code (focus on user-visible errors)

**Diagram Structure:**
- Use `flowchart TD` (top-down layout)
- Use rectangle nodes `[]` for screens/pages
- Use rounded rectangle `()` for dialogs/popups/bottom sheets
- Use decision diamonds `{}` for user choices or conditional navigation
- Use rounded edges `([])` for entry/exit points
- Label ALL arrows with user actions or conditions
- Group related screens with subgraphs if needed

**Styling Requirements:**
- ðŸŸ¢ **Entry/Success screens**: Green background (#2E7D32), white text
- ðŸ”µ **Main screens**: Blue background (#1565C0), white text
- ðŸŸ¡ **Dialogs/Popups**: Yellow background (#F9A825), dark text
- ðŸ”´ **Error screens**: Red background (#C62828), white text
- ðŸŸ£ **Loading/Progress screens**: Purple background (#7B1FA2), white text
- âšª **Regular screens**: Default styling

**Additional Requirements:**
- Add notes explaining complex navigation flows
- Show parallel screens if multiple activities/fragments are visible
- Include tab navigation, drawer navigation, bottom navigation if present
- Show permission request screens if applicable
- Include onboarding or tutorial screens if they exist
- Document screen orientation changes if relevant
- Show keyboard interactions (show/hide keyboard, input focus)
- Include web view screens if applicable
- DO NOT skip any screens that exist in the code path
- DO NOT combine multiple screens into one node
- Every code navigation must have a corresponding arrow
- **CRITICAL**: Analyze the COMPLETE navigation code before creating the diagram. Don't make assumptions about screen flow - read it thoroughly.
- Trace ALL navigation function calls to their implementations
- Follow ALL conditional navigation logic (if statements controlling screen routing)
- Include ALL error-triggered navigation (network errors showing error screens, validation failures)
- Document ALL edge case screens (empty states, first-time user flows, logged-out states)
- Show ALL timeout handling that affects UI
- Include ALL retry mechanisms visible to users
- Document ALL navigation stack manipulation (clear stack, replace root, etc.)
- Show ALL animation or transition types if they affect user understanding

**Files to analyze:**
[List the specific activities, fragments, navigation files, or UI-related classes]

**Starting screen:**
[Specify the entry point screen - e.g., "Start from Payment Details Screen when user selects Google Pay"]

**User journey:**
[Briefly describe the user journey - e.g., "User selects payment method, enters details, completes payment"]

**Analysis Process:**
1. **First Pass**: Read ALL UI/navigation files completely to understand the screen structure
2. **Second Pass**: Trace navigation code from entry point, following ALL screen transitions
3. **Third Pass**: Identify ALL conditional navigation, error screens, edge cases, permission flows
4. **Fourth Pass**: Verify all navigation paths lead to proper screens (success, error, back, cancel)
5. **Create Diagram**: Build the flowchart with complete accuracy including ALL screen scenarios

**Output:**
Generate a complete, ACCURATE Mermaid flowchart as .md file that:
1. Traces actual code to show exact screen navigation flow
2. Displays all screens, dialogs, and user interactions
3. Shows what users see and do at each step
4. Includes ALL edge case screens (errors, empty states, loading states, timeout screens)
5. Shows ALL conditional navigation and feature-flagged screens
6. Documents ALL error handling UI and retry mechanisms
7. Can be used by UI/UX designers, QA testers, and product teams
8. Maintains 100% accuracy - all screens and transitions match the code
Save the diagram to: `doc/diagrams/ui-flow/[feature-name]-screen-flow.md`
```

### Example Usage

```
I need you to analyze the code and create a SCREEN/PAGE FLOW Mermaid flowchart diagram showing the user interface navigation and interactions. The diagram must be 100% ACCURATE by tracing the actual code implementation.

**CRITICAL REQUIREMENTS:**
[All requirements as listed above]

**Files to analyze:**
- CheckoutPage.tsx
- PaymentForm.vue
- VerificationScreen.swift
- SuccessPage.jsx
- ErrorPage.py
- NavigationController.cs (if exists)
- All related UI views/pages/components in the checkout flow

**Starting screen:**
Start from Shopping Cart Screen when user clicks "Proceed to Checkout" button

**User journey:**
User reviews cart â†’ Enters shipping details â†’ Selects payment method â†’ Confirms order â†’ Sees confirmation

**Output:**
Generate a complete, ACCURATE Mermaid flowchart as .md file that:
1. Traces actual code to show exact screen navigation flow
2. Displays all screens, dialogs, and user interactions
3. Shows what users see and do at each step
4. Can be used by UI/UX designers, QA testers, and product teams
5. Maintains 100% accuracy - all screens and transitions match the code
Save the diagram to: `doc/diagrams/ui-flow/[feature-name]-screen-flow.md`
```

---

## ðŸ”„ Combined Workflow

For a complete diagram generation approach:

### When to Use Each Prompt:

**Use Prompt 1 (Detailed Technical Diagram) when:**
- Doing code reviews or technical documentation
- Debugging complex issues
- Onboarding new developers who need to understand implementation
- Documenting API integrations and technical flows
- Need to see exact method calls and error handling

**Use Prompt 2 (Business Logic Diagram) when:**
- Creating presentations for stakeholders or management
- Documenting business requirements
- Communicating with product managers or business analysts
- Creating user journey documentation
- Need high-level overview of feature functionality

**Use Prompt 3 (Executive/Manager Report Diagram) when:**
- Presenting to executives, senior management, or C-level
- Creating status reports for non-technical managers
- Explaining features to investors or board members
- Need 100% accurate flow but in completely plain language
- Preparing presentations for project reviews or audits
- Documenting for regulatory compliance or external audits

**Use Prompt 4 (Screen/Page Flow Diagram) when:**
- Documenting UI/UX flows for designers
- Creating test plans and test cases for QA teams
- Onboarding new team members on app navigation
- Reviewing user journeys and navigation patterns
- Documenting screen transitions for product documentation
- Creating user guides or help documentation
- Analyzing and optimizing navigation flows
- Need to understand how users move through the application

### Step-by-Step Process:

#### For Technical Documentation:
1. Use **Prompt 1** to analyze code and generate detailed Mermaid diagram
2. Review and validate against actual code implementation
3. Diagram will be saved to `doc/diagrams/technical/[feature-name]-technical.md`

#### For Business Documentation:
1. Use **Prompt 2** to extract business logic and generate high-level diagram
2. Review with business stakeholders for accuracy
3. Diagram will be saved to `doc/diagrams/business/[feature-name]-business.md`

#### For Executive/Manager Reports:
1. Use **Prompt 3** to create manager-friendly diagram with plain language
2. Verify accuracy against code but ensure language is non-technical
3. Diagram will be saved to `doc/diagrams/executive/[feature-name]-executive.md`

#### For UI/UX Documentation:
1. Use **Prompt 4** to trace code and generate screen flow diagram
2. Review with UI/UX team and validate all screens exist
3. Diagram will be saved to `doc/diagrams/ui-flow/[feature-name]-screen-flow.md`

#### For Complete Documentation:
1. Generate all four diagrams (Prompts 1, 2, 3, and 4)
2. Use technical diagram (Prompt 1) for developer reference
3. Use business diagram (Prompt 2) for product team communication
4. Use executive diagram (Prompt 3) for management reporting
5. Use screen flow diagram (Prompt 4) for UI/UX team and QA testing
6. Link all four in your comprehensive feature documentation

---

## ðŸ’¡ Tips for Best Results

### For Code Analysis (Prompt 1):
1. **Be specific about scope** - List exact files/methods to analyze
2. **Specify the entry point** - Where should the flow analysis start?
3. **Mention special cases** - Feature flags, environment-specific logic, A/B tests
4. **Request specific detail level** - "Include all error handling" or "Show high-level flow only"
5. **Provide context** - Mention the business feature (e.g., "Checkout flow", "User registration", "Data import")

### For Business Logic Analysis (Prompt 2):
1. **Focus on the business feature** - Clearly state what business process you're documenting
2. **Identify key decision points** - What are the critical business decisions?
3. **Specify the audience** - Mention if it's for stakeholders, product team, or documentation
4. **Request appropriate abstraction** - "Executive summary level" or "Product manager level"
5. **Include business context** - Regulatory requirements, business rules, user expectations

### For Executive/Manager Reports (Prompt 3):
1. **Emphasize accuracy** - Stress that flow must match code exactly
2. **Specify plain language** - Request everyday language, no technical terms
3. **Define the audience** - State it's for managers, executives, or non-technical stakeholders
4. **Request translations** - Ask for technical terms to be explained in simple words
5. **Include context** - Mention what the feature does from a user/customer perspective

### For Screen/Page Flow Diagrams (Prompt 4):
1. **List all UI files** - Activities, Fragments, navigation components
2. **Specify entry screen** - Where does the user journey start?
3. **Describe user journey** - What is the user trying to accomplish?
4. **Mention navigation patterns** - Tab navigation, drawer, bottom nav, etc.
5. **Include edge cases** - Error screens, permission dialogs, empty states

### For Complex Diagrams:
1. **Consider breaking into sub-diagrams** - One technical, one business-focused, one UI flow
2. **Use sequence diagrams for temporal flows** - Better for showing time-based interactions
3. **Use class diagrams for structure** - Better for showing relationships between components
4. **Create layered documentation** - Executive summary â†’ Business logic â†’ Technical details â†’ UI flow
5. **Maintain consistency** - Use same styling and naming conventions across all diagrams

---

## ðŸ“ Example Use Cases

### Use Case 1: Checkout/Payment Flow
**Technical Diagram (Prompt 1):**
```
Files: PaymentService.py, OrderProcessor.java, PaymentGateway.ts, validation handlers
Entry: User clicks "Complete Order" button
Focus: Complete payment lifecycle including validation, API calls, error handling, transaction processing
```

**Business Diagram (Prompt 2):**
```
Files: Same as above
Feature: Order checkout and payment processing
Focus: Order validation â†’ Payment authorization â†’ Confirmation flow from business perspective
```

**Executive Diagram (Prompt 3):**
```
Files: Same as above
Feature: How customers complete their purchases
Focus: Exact same flow as technical, but explained in plain language for manager reporting
```

**Screen Flow Diagram (Prompt 4):**
```
Files: CheckoutPage.tsx, PaymentForm.vue, ConfirmationScreen.swift
Entry: Shopping Cart Screen
Focus: Screen navigation, user interactions, buttons, forms, dialogs, and UI transitions
```

### Use Case 2: User Authentication Flow
**Technical Diagram (Prompt 1):**
```
Files: AuthController.cs, UserService.java, TokenManager.py, SessionHandler.rb
Entry: User opens login page
Focus: All authentication methods, token management, session handling, error scenarios
```

**Business Diagram (Prompt 2):**
```
Files: Same as above
Feature: User authentication and account access
Focus: Login options â†’ Credential validation â†’ Account access (business perspective)
```

**Executive Diagram (Prompt 3):**
```
Files: Same as above
Feature: How users log into the system
Focus: Exact authentication flow explained in everyday language for executive reporting
```

**Screen Flow Diagram (Prompt 4):**
```
Files: LoginPage.jsx, SignUpForm.vue, ResetPassword.tsx, VerificationScreen.swift
Entry: Application Home Page or Login Button
Focus: Login screen â†’ Credential entry â†’ Verification â†’ Dashboard, including sign up and password reset paths
```

### Use Case 3: Data Import/Processing Workflow
**Technical Diagram (Prompt 1):**
```
Files: ImportService.java, DataValidator.py, FileProcessor.ts, TransformationEngine.cs
Entry: User uploads file or initiates import
Focus: File parsing â†’ Validation â†’ Transformation â†’ Storage with all technical details
```

**Business Diagram (Prompt 2):**
```
Files: Same as above
Feature: Data import and processing workflow
Focus: File upload â†’ Data validation â†’ Processing â†’ Storage (business perspective)
```

**Executive Diagram (Prompt 3):**
```
Files: Same as above
Feature: How data is imported into the system
Focus: Complete import process in simple terms for management presentations
```

**Screen Flow Diagram (Prompt 4):**
```
Files: UploadPage.tsx, ValidationScreen.vue, ProgressView.swift, ResultsPage.jsx
Entry: Import Dashboard
Focus: Upload screen â†’ Validation feedback â†’ Progress indicator â†’ Results summary
```

---

## ðŸŽ¯ Quality Checklist

### For Technical Diagrams (Prompt 1):
- [ ] All code paths are represented
- [ ] All API calls are documented with endpoints
- [ ] All error scenarios are shown
- [ ] All user interactions are captured
- [ ] Decision points match actual code logic
- [ ] Data flow is clear and accurate
- [ ] Styling is consistent and meaningful
- [ ] Labels include method/function names
- [ ] Technical error handling is complete

### For Business Logic Diagrams (Prompt 2):
- [ ] Business processes are clearly labeled
- [ ] Decision points reflect business rules
- [ ] User journey is easy to follow
- [ ] No technical jargon or implementation details
- [ ] Outcomes are from business perspective
- [ ] Stakeholders can understand without technical knowledge
- [ ] Key business validations are shown
- [ ] External systems are identified at high level

### For Executive/Manager Diagrams (Prompt 3):
- [ ] Flow matches the actual code 100% accurately
- [ ] Every step, decision, and path from code is included
- [ ] ALL technical terms are translated to plain language
- [ ] No code terminology (API, methods, functions, etc.)
- [ ] Language is understandable by anyone (non-technical)
- [ ] Boxes explain WHAT happens, not HOW
- [ ] Arrows and conditions use everyday language
- [ ] External systems described in simple terms
- [ ] Can be presented to executives without explanation

### For Screen/Page Flow Diagrams (Prompt 4):
- [ ] All screens traced from actual code implementation
- [ ] Every screen transition matches code navigation
- [ ] All user interactions and actions are shown
- [ ] Dialogs, popups, and bottom sheets are included
- [ ] Error screens and loading states are documented
- [ ] Back button behavior is clear
- [ ] User actions are clearly labeled on arrows
- [ ] Screen states (loading, error, success) are shown
- [ ] Navigation patterns are accurate
- [ ] Can be used for UI/UX design and QA testing

### For All Diagram Types:
- [ ] ALL related code files were read completely before creating diagram
- [ ] ALL function/method calls were traced to their implementations
- [ ] ALL decision points from code are represented
- [ ] ALL error handling paths are included
- [ ] ALL edge cases handled in code are shown
- [ ] ALL retry/fallback mechanisms are documented
- [ ] ALL timeout and async handling is represented
- [ ] ALL validation and boundary checks are included
- [ ] Diagram is readable at normal zoom level
- [ ] No dead ends (all paths lead somewhere)
- [ ] Success and failure paths are complete
- [ ] Edge labels explain the conditions clearly
- [ ] Styling helps distinguish different types of nodes
- [ ] Diagram serves its intended purpose and audience
- [ ] No assumptions were made - everything traces back to actual code

---

## ðŸ“š Additional Resources

### Mermaid Documentation (for reference not included in AI generation)
- Official Docs: https://mermaid.js.org/
- Flowchart Syntax: https://mermaid.js.org/syntax/flowchart.html
- Live Editor: https://mermaid.live/

### Draw.io Resources (for reference not included in AI generation)
- Desktop App: https://www.diagrams.net/
- VS Code Extension: "Draw.io Integration"
- Import Mermaid: Use File â†’ Import â†’ Select Mermaid (.md) file

### Diagram Best Practices
- **Technical diagrams (Prompt 1)**: Keep nodes concise but include technical details
- **Business diagrams (Prompt 2)**: Use business-friendly language, avoid technical terms
- **Executive diagrams (Prompt 3)**: Use plain everyday language, maintain 100% accuracy
- **Screen flow diagrams (Prompt 4)**: Focus on UI elements and user interactions, trace actual navigation code
- Use consistent naming conventions across related diagrams
- Group related operations visually with subgraphs
- Limit diagram width to maintain readability
- Use colors purposefully (success, error, API, external systems, screens, dialogs, etc.)
- Add legends if using custom symbols or colors
- Version control your diagrams alongside code
- **Match diagrams to audience**: Technical for developers, Business for product team, Executive for management, Screen Flow for UI/UX and QA

---

*Last Updated: November 13, 2025*
*Version: 2.4*
*Major Changes: 
- v2.0: Replaced Draw.io conversion prompt with Business Logic diagram generation prompt
- v2.1: Enhanced Prompt 2 and 3 with complete accuracy requirements from Prompt 1
- v2.2: Added interactive menu for easy diagram style selection based on user role
- v2.3: Added AI Assistant Instructions section with clear intent recognition rules, decision logic, and examples to prevent assumptions. AI must show menu when user intent is unclear.
- v2.4: Added Prompt 4 - Screen/Page Flow Diagram (UI/UX) for documenting screen navigation and user interactions by tracing actual code. Updated menu to include Option 4, added shortcuts, examples, quality checklist items, and best practices for UI/UX diagrams.*

*NOTE*
- Diagrams produced may contain errors. Please validate the diagram before proceeding with any changes or decisions.
